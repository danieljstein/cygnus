# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Z-score a sparse matrix across each row
#'
#' @param x,p,i Internal data structures from a
#'   sparse matrix in dgCMatrix format.
#' @param ncol,nrow Dimensions of sparse matrix input.
#' @param thresh Z-scores above `thresh` and below
#'   `-thresh` are clipped to `thresh` and `-thresh`,
#'   respectively.
#'
#' @returns A dense matrix in column-major ordering
#'   with dimensions `nrow` x `ncol`.
scaleRows_dgc <- function(x, p, i, ncol, nrow, thresh) {
    .Call('_cygnus_scaleRows_dgc', PACKAGE = 'cygnus', x, p, i, ncol, nrow, thresh)
}

st_mats_perimeter <- function(Xvec) {
    .Call('_cygnus_st_mats_perimeter', PACKAGE = 'cygnus', Xvec)
}

get_e_minus_epaths_saddles <- function(epaths, saddles, N) {
    .Call('_cygnus_get_e_minus_epaths_saddles', PACKAGE = 'cygnus', epaths, saddles, N)
}

is_in_list <- function(target, mylist) {
    .Call('_cygnus_is_in_list', PACKAGE = 'cygnus', target, mylist)
}

mergeListsToArmaUVec <- function(list1, list2) {
    .Call('_cygnus_mergeListsToArmaUVec', PACKAGE = 'cygnus', list1, list2)
}

findDuplicates <- function(input) {
    .Call('_cygnus_findDuplicates', PACKAGE = 'cygnus', input)
}

update_V_cpp <- function(V_pcs, V_npts, V_perimeter, V_area, e_merge_from, e_merge_to, e_merge_edge_length, e_merge_area, e_merge_npts, e_merge_pcs, agg_mode) {
    invisible(.Call('_cygnus_update_V_cpp', PACKAGE = 'cygnus', V_pcs, V_npts, V_perimeter, V_area, e_merge_from, e_merge_to, e_merge_edge_length, e_merge_area, e_merge_npts, e_merge_pcs, agg_mode))
}

update_E_cpp <- function(V_pcs, V_perimeter, V_area, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, e_update, V_to_E_from, V_to_E_to, d_mu, d_sig, agg_mode, min_npts, max_npts) {
    invisible(.Call('_cygnus_update_E_cpp', PACKAGE = 'cygnus', V_pcs, V_perimeter, V_area, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, e_update, V_to_E_from, V_to_E_to, d_mu, d_sig, agg_mode, min_npts, max_npts))
}

merge_aggs_cpp <- function(V_pcs, V_area, V_perimeter, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, d_mu, d_sig, iter_max, agg_mode, dscore_thresh, min_npts, max_npts) {
    .Call('_cygnus_merge_aggs_cpp', PACKAGE = 'cygnus', V_pcs, V_area, V_perimeter, V_npts, E_from, E_to, E_npts, E_area, E_edge_length, E_pcs_merge, E_w, E_perimeter_merge, E_score_size, E_dscore, d_mu, d_sig, iter_max, agg_mode, dscore_thresh, min_npts, max_npts)
}

foo_triplets_edges <- function(triplets, edges) {
    .Call('_cygnus_foo_triplets_edges', PACKAGE = 'cygnus', triplets, edges)
}

do_dmt_forest_cpp <- function(f, edges_from, edges_to, edges_f) {
    .Call('_cygnus_do_dmt_forest_cpp', PACKAGE = 'cygnus', f, edges_from, edges_to, edges_f)
}

trace_back_cpp <- function(v0, vcrit, parent_edge, parent) {
    .Call('_cygnus_trace_back_cpp', PACKAGE = 'cygnus', v0, vcrit, parent_edge, parent)
}

trace_epaths_cpp <- function(saddles, vcrits, edges_from, edges_to, parent_edge, parent) {
    .Call('_cygnus_trace_epaths_cpp', PACKAGE = 'cygnus', saddles, vcrits, edges_from, edges_to, parent_edge, parent)
}

get_e_sep <- function(epaths, saddles, nedges) {
    .Call('_cygnus_get_e_sep', PACKAGE = 'cygnus', epaths, saddles, nedges)
}

prune_e_sep <- function(edges, ntris, is_tri_external, e_sep) {
    .Call('_cygnus_prune_e_sep', PACKAGE = 'cygnus', edges, ntris, is_tri_external, e_sep)
}

#' Bilateral / anisotropic filtering of gradient field
#' 
#' Gradient fields are smoothed using bilateral filtering,
#' in which the smoothed gradient of each point is computed as
#' the weighted average of the neighbors' gradients, considering
#' both distance in space and also similarity in gradients.
#' 
#' @param pvec,adj_i,adj_p A `N` x `N` sparse adjacency matrix
#'   in dgCMatrix format: `pvec = diff(adj@p)`, `adj_i = adj@i`,
#'   and `adj_p = adj@p`
#' @param field A `2` x `D` x `N` array in column-major ordering
#'   containing the spatial gradient in expression for each of
#'   `D` latent variables at every point in space.
#' @param coords A `N` x `2` matrix of cell coordinates.
#' @param distance Method for computing distance score in weighted average.
#'   See description for details. Defaults to `'euclidean'`.
#' @param similarity Method for computing similarity score in weighted average.
#'   See description for details. Defaults to `'euclidean'`.
#' 
#' @returns A `2` x `D` x `N` array in column-major ordering
#'   containing the smoothed spatial gradient in expression for each of
#'   `D` latent variables at every point in space.
#' 
smooth_field_cpp <- function(pvec, adj_i, adj_p, field, coords, distance, similarity) {
    .Call('_cygnus_smooth_field_cpp', PACKAGE = 'cygnus', pvec, adj_i, adj_p, field, coords, distance, similarity)
}

compress_field_cpp <- function(field) {
    .Call('_cygnus_compress_field_cpp', PACKAGE = 'cygnus', field)
}

#' Compute a spatial gradient field at each point (cell)
#'
#' Distance between neighboring cells is normalized to unit distance
#' so that only the direction from each cell to its neighbors matters.
#' The gradient is then the average gradient in expression of each
#' embedding dimension between the index cell and its neighbors.
#'
#' @param coords A `N` x `2` matrix of cell coordinates.
#' @param embeddings A `N` x `D` matrix of cell embeddings.
#' @param adj_i,adj_p A `N` x `N` sparse adjacency matrix
#'   in dgCMatrix format.
#'
#' @returns A `2` x `D` x `N` array in column-major ordering
#'   containing the spatial gradient in expression for each of
#'   `D` embedding dimensions at every point in space.
#'
estimate_field_cpp <- function(coords, embeddings, adj_i, adj_p) {
    .Call('_cygnus_estimate_field_cpp', PACKAGE = 'cygnus', coords, embeddings, adj_i, adj_p)
}

#' Assigns a unique ID to each point with distinct X,Y coordinates
#'
#' @param X,Y A pair of numeric vectors with the coordinates for each point.
#'
#' @returns A vector with the same length as `X` and `Y` containing
#'   IDs that range from 0 to N where N is the number of unique points.
#' 
assign_unique_rowid_cpp <- function(X, Y) {
    .Call('_cygnus_assign_unique_rowid_cpp', PACKAGE = 'cygnus', X, Y)
}

#' Calculates triangles' centroids, areas, and heights from vertices
#'
#' @param triplets A M-by-3 matrix with indices for the points that
#'   correspond each triangle's vertices, where M is the number of triangles.
#' @param pts A N-by-2 matrix with indices for the X,Y coordinates of
#'   each point.
#' @param tris A M-by-4 matrix containing the X,Y coordinates of each
#'   triangle's centroid in the first two columns, and area and
#'   largest height of each triangle in the last two columns.
#'
#' @returns A E-by-14 matrix with columns `from_pt`, `to_pt`, `from_tri`, `to_tri`,
#'   `x0_pt`, `x1_pt`, `y0_pt`, `y1_pt`, `x0_tri`, `x1_tri`, `y0_tri`, `y1_tri`,
#'   `length_pt`, `length_tri`. If only one triangle uses an edge, then the `from_tri`,
#'   `x0_tri`, and `y0_tri` fields will contain NaN values.
#'
#'   Note that indices that reference the `pts` and `tris` tables are 1-indexed.
#' 
init_edges_cpp <- function(triplets, pts, tris) {
    .Call('_cygnus_init_edges_cpp', PACKAGE = 'cygnus', triplets, pts, tris)
}

#' Calculates triangles' centroids, areas, and heights from vertices
#'
#' @param triplets A M-by-3 matrix with indices for the points that
#'   correspond each triangle's vertices, where M is the number of triangles.
#' @param pts A N-by-2 matrix with indices for the X,Y coordinates of
#'   each point.
#' 
#' @returns A M-by-4 matrix containing the X,Y coordinates of each
#'   triangle's centroid in the first two columns, and area and
#'   largest height of each triangle in the last two columns.
#' 
init_tris_cpp <- function(triplets, pts) {
    .Call('_cygnus_init_tris_cpp', PACKAGE = 'cygnus', triplets, pts)
}

mapToConsecutivePositions <- function(numbers) {
    .Call('_cygnus_mapToConsecutivePositions', PACKAGE = 'cygnus', numbers)
}

splitSequence <- function(y) {
    .Call('_cygnus_splitSequence', PACKAGE = 'cygnus', y)
}

findLargestComponentEulerCycle <- function(edges) {
    .Call('_cygnus_findLargestComponentEulerCycle', PACKAGE = 'cygnus', edges)
}

get_agg_to_boundary_edge <- function(E, n_agg) {
    .Call('_cygnus_get_agg_to_boundary_edge', PACKAGE = 'cygnus', E, n_agg)
}

get_agg_to_edge <- function(edges, naggs, always_include_boundary) {
    .Call('_cygnus_get_agg_to_edge', PACKAGE = 'cygnus', edges, naggs, always_include_boundary)
}

get_boundary_graph_cpp <- function(e_dual, i_pts, e_prim, E, ntris) {
    .Call('_cygnus_get_boundary_graph_cpp', PACKAGE = 'cygnus', e_dual, i_pts, e_prim, E, ntris)
}

trace_polygons_cpp <- function(edges, naggs, ntris, pts_dmt_component) {
    .Call('_cygnus_trace_polygons_cpp', PACKAGE = 'cygnus', edges, naggs, ntris, pts_dmt_component)
}

trace_polygons_pts_cpp <- function(edges, naggs) {
    .Call('_cygnus_trace_polygons_pts_cpp', PACKAGE = 'cygnus', edges, naggs)
}

